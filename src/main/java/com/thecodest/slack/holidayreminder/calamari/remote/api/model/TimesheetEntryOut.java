/*
 * Calamari API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1
 * Contact: developers@calamari.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.thecodest.slack.holidayreminder.calamari.remote.api.model;

import com.google.gson.annotations.SerializedName;
import io.swagger.v3.oas.annotations.media.Schema;

import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * TimesheetEntryOut
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2022-07-06T15:14:15.923389380+02:00[Europe/Warsaw]")
public class TimesheetEntryOut {
	@SerializedName("id")
	private Long id = null;

	@SerializedName("started")
	private OffsetDateTime started = null;

	@SerializedName("finished")
	private OffsetDateTime finished = null;

	@SerializedName("startedTimeZone")
	private TimeZone startedTimeZone = null;

	@SerializedName("finishedTimeZone")
	private TimeZone finishedTimeZone = null;

	@SerializedName("duration")
	private Long duration = null;

	@SerializedName("person")
	private EmployeeSimpleOut person = null;

	@SerializedName("breaks")
	private List<BreakDto> breaks = new ArrayList<>();

	@SerializedName("projects")
	private List<ProjectDto> projects = new ArrayList<>();

	@SerializedName("closed")
	private Boolean closed = null;

	public TimesheetEntryOut id(Long id) {
		this.id = id;
		return this;
	}

	/**
	 * Timesheet entry ID
	 *
	 * @return id
	 **/
	@Schema(required = true, description = "Timesheet entry ID")
	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public TimesheetEntryOut started(OffsetDateTime started) {
		this.started = started;
		return this;
	}

	/**
	 * Date and time of timesheet entry started
	 *
	 * @return started
	 **/
	@Schema(required = true, description = "Date and time of timesheet entry started")
	public OffsetDateTime getStarted() {
		return started;
	}

	public void setStarted(OffsetDateTime started) {
		this.started = started;
	}

	public TimesheetEntryOut finished(OffsetDateTime finished) {
		this.finished = finished;
		return this;
	}

	/**
	 * Date and time of timesheet entry finished. Has null value if employee does not clock out
	 *
	 * @return finished
	 **/
	@Schema(description = "Date and time of timesheet entry finished. Has null value if employee does not clock out")
	public OffsetDateTime getFinished() {
		return finished;
	}

	public void setFinished(OffsetDateTime finished) {
		this.finished = finished;
	}

	public TimesheetEntryOut startedTimeZone(TimeZone startedTimeZone) {
		this.startedTimeZone = startedTimeZone;
		return this;
	}

	/**
	 * Get startedTimeZone
	 *
	 * @return startedTimeZone
	 **/
	@Schema(required = true, description = "")
	public TimeZone getStartedTimeZone() {
		return startedTimeZone;
	}

	public void setStartedTimeZone(TimeZone startedTimeZone) {
		this.startedTimeZone = startedTimeZone;
	}

	public TimesheetEntryOut finishedTimeZone(TimeZone finishedTimeZone) {
		this.finishedTimeZone = finishedTimeZone;
		return this;
	}

	/**
	 * Get finishedTimeZone
	 *
	 * @return finishedTimeZone
	 **/
	@Schema(description = "")
	public TimeZone getFinishedTimeZone() {
		return finishedTimeZone;
	}

	public void setFinishedTimeZone(TimeZone finishedTimeZone) {
		this.finishedTimeZone = finishedTimeZone;
	}

	public TimesheetEntryOut duration(Long duration) {
		this.duration = duration;
		return this;
	}

	/**
	 * Duration of timesheet entry in seconds. Has 0 value if employee does not clock out.
	 *
	 * @return duration
	 **/
	@Schema(example = "28800", required = true, description = "Duration of timesheet entry in seconds. Has 0 value if employee does not clock out.")
	public Long getDuration() {
		return duration;
	}

	public void setDuration(Long duration) {
		this.duration = duration;
	}

	public TimesheetEntryOut person(EmployeeSimpleOut person) {
		this.person = person;
		return this;
	}

	/**
	 * Get person
	 *
	 * @return person
	 **/
	@Schema(required = true, description = "")
	public EmployeeSimpleOut getPerson() {
		return person;
	}

	public void setPerson(EmployeeSimpleOut person) {
		this.person = person;
	}

	public TimesheetEntryOut breaks(List<BreakDto> breaks) {
		this.breaks = breaks;
		return this;
	}

	public TimesheetEntryOut addBreaksItem(BreakDto breaksItem) {
		this.breaks.add(breaksItem);
		return this;
	}

	/**
	 * List of breaks
	 *
	 * @return breaks
	 **/
	@Schema(required = true, description = "List of breaks")
	public List<BreakDto> getBreaks() {
		return breaks;
	}

	public void setBreaks(List<BreakDto> breaks) {
		this.breaks = breaks;
	}

	public TimesheetEntryOut projects(List<ProjectDto> projects) {
		this.projects = projects;
		return this;
	}

	public TimesheetEntryOut addProjectsItem(ProjectDto projectsItem) {
		this.projects.add(projectsItem);
		return this;
	}

	/**
	 * List of projects
	 *
	 * @return projects
	 **/
	@Schema(required = true, description = "List of projects")
	public List<ProjectDto> getProjects() {
		return projects;
	}

	public void setProjects(List<ProjectDto> projects) {
		this.projects = projects;
	}

	public TimesheetEntryOut closed(Boolean closed) {
		this.closed = closed;
		return this;
	}

	/**
	 * Is shift closed?
	 *
	 * @return closed
	 **/
	@Schema(required = true, description = "Is shift closed?")
	public Boolean isClosed() {
		return closed;
	}

	public void setClosed(Boolean closed) {
		this.closed = closed;
	}

	@Override
	public boolean equals(Object o) {
		if(this == o) {
			return true;
		}
		if(o == null || getClass() != o.getClass()) {
			return false;
		}
		TimesheetEntryOut timesheetEntryOut = (TimesheetEntryOut) o;
		return Objects.equals(this.id, timesheetEntryOut.id) && Objects.equals(this.started, timesheetEntryOut.started) && Objects.equals(this.finished, timesheetEntryOut.finished) && Objects.equals(this.startedTimeZone, timesheetEntryOut.startedTimeZone) && Objects.equals(this.finishedTimeZone, timesheetEntryOut.finishedTimeZone) && Objects.equals(this.duration, timesheetEntryOut.duration) && Objects.equals(this.person, timesheetEntryOut.person) && Objects.equals(this.breaks, timesheetEntryOut.breaks) && Objects.equals(this.projects, timesheetEntryOut.projects) && Objects.equals(this.closed, timesheetEntryOut.closed);
	}

	@Override
	public int hashCode() {
		return Objects.hash(id, started, finished, startedTimeZone, finishedTimeZone, duration, person, breaks, projects, closed);
	}

	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("class TimesheetEntryOut {\n");

		sb.append("    id: ").append(toIndentedString(id)).append("\n");
		sb.append("    started: ").append(toIndentedString(started)).append("\n");
		sb.append("    finished: ").append(toIndentedString(finished)).append("\n");
		sb.append("    startedTimeZone: ").append(toIndentedString(startedTimeZone)).append("\n");
		sb.append("    finishedTimeZone: ").append(toIndentedString(finishedTimeZone)).append("\n");
		sb.append("    duration: ").append(toIndentedString(duration)).append("\n");
		sb.append("    person: ").append(toIndentedString(person)).append("\n");
		sb.append("    breaks: ").append(toIndentedString(breaks)).append("\n");
		sb.append("    projects: ").append(toIndentedString(projects)).append("\n");
		sb.append("    closed: ").append(toIndentedString(closed)).append("\n");
		sb.append("}");
		return sb.toString();
	}

	/**
	 * Convert the given object to string with each line indented by 4 spaces
	 * (except the first line).
	 */
	private String toIndentedString(Object o) {
		if(o == null) {
			return "null";
		}
		return o.toString().replace("\n", "\n    ");
	}

}
